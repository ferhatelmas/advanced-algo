\begin{enumerate}
  \item
     Suppose there are no $u$ and $v$ satisfying $w(u) > c \cdot w(v)$. Given that $^1/_2 < c < 1$ implies that there is no child-node having more than half of the nodes of its parent-node. Thus, there are two cases: 
    \begin{itemize}
      \item 
      the subtree will be heavier on the other direction which we aren't coming on but this will satisfy the above equation in one up level.
      
      \item 
      all siblings should have equal weights and tree should be  balanced. As we have seen in the first question, the depth of a \textit{balanced} tree is $\log n$. Therefore, it is also impossible because $d(x) > b \cdot log n$ where $b > 1$.
    \end{itemize}        

    From these two cases, the tree is unbalanced. Therefore, in the path from $x$ to \textit{root}, we will find a point where that unbalance comes from. Since tree is binary, if tree was balanced, each child would equally share the nodes of its parent, that means each child can have at most half of weight of its parent. However, it is unbalanced so one child will certainly have nodes under its subtrees more than half of weight of its parent.
    
  \item
   Since we rearrange the tree to make it balanced again when a node has a degree larger than $b \cdot \log n$, the height of tree will be bounded by the bound we do the rearrangement, which is $b \cdot \log n$, here.
  
  \item
  \begin{itemize}
    \item \textit{find} operation can take the longest path in the worst case such as unsuccessful search. From point $2$, we know that the height of tree is bounded by $b \cdot \log n$ so the longest path is bounded by $O(\log n)$.
    
    \item \textit{add} operation is more complex compared with \textit{find}. Its cost is composed of executing find and then checking weights from the node, where the \textit{find} took us, to root (here we assume that each node knows to answer its weight) and doing rearrangement. In the worst case, we will rearrange the whole tree so we have the following $n$ items of tree and $T$ denotes the whole tree:
    
    \begin{align*}
      add\text{ } &= find + weight\text{ }check + rearrangement \\
                  &= O(\log n) + O(\log n) + sort(T) + create(T) \\
                  &= O(\log n) + O(n \log n) + (2T(^n/_2) + O(1)) \\
                  &= O(n \log n) + O(n) \\
                  &= O(n \log n) \\
    \end{align*}
  \end{itemize}
  
  \item


\end{enumerate}